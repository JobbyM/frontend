<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS | 我的前端小册</title>
    <meta name="description" content="我的前端小册">
    
    
    <link rel="preload" href="/frontend/assets/css/0.styles.2bb30ae6.css" as="style"><link rel="preload" href="/frontend/assets/js/app.564d1f95.js" as="script"><link rel="preload" href="/frontend/assets/js/2.3b24a225.js" as="script"><link rel="preload" href="/frontend/assets/js/7.55063cd5.js" as="script"><link rel="prefetch" href="/frontend/assets/js/10.0f9a919f.js"><link rel="prefetch" href="/frontend/assets/js/11.3cf84b63.js"><link rel="prefetch" href="/frontend/assets/js/12.7d818715.js"><link rel="prefetch" href="/frontend/assets/js/13.e575ab13.js"><link rel="prefetch" href="/frontend/assets/js/14.b096c1c0.js"><link rel="prefetch" href="/frontend/assets/js/15.418b324a.js"><link rel="prefetch" href="/frontend/assets/js/16.bcc1b39e.js"><link rel="prefetch" href="/frontend/assets/js/3.9c85f066.js"><link rel="prefetch" href="/frontend/assets/js/4.bbe5a1b5.js"><link rel="prefetch" href="/frontend/assets/js/5.7b2613d4.js"><link rel="prefetch" href="/frontend/assets/js/6.6ded86ab.js"><link rel="prefetch" href="/frontend/assets/js/8.e5cc8a9f.js"><link rel="prefetch" href="/frontend/assets/js/9.9d6f5881.js">
    <link rel="stylesheet" href="/frontend/assets/css/0.styles.2bb30ae6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/frontend/" class="home-link router-link-active"><!----> <span class="site-name">我的前端小册</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/frontend/" class="nav-link">HOME</a></div><div class="nav-item"><a href="/frontend/js/" class="nav-link router-link-exact-active router-link-active">前端</a></div><div class="nav-item"><a href="/frontend/network/" class="nav-link">计算机通识</a></div><div class="nav-item"><a href="https://jobbym.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/frontend/" class="nav-link">HOME</a></div><div class="nav-item"><a href="/frontend/js/" class="nav-link router-link-exact-active router-link-active">前端</a></div><div class="nav-item"><a href="/frontend/network/" class="nav-link">计算机通识</a></div><div class="nav-item"><a href="https://jobbym.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/frontend/" class="sidebar-link">Home</a></li><li><section class="sidebar-group depth-0"><a href="/frontend/js/" class="sidebar-heading clickable router-link-exact-active router-link-active open active"><span>前端</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/frontend/js/" class="active sidebar-link">JS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/#内置类型" class="sidebar-link">内置类型</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#typeof" class="sidebar-link">typeof</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#类型转换" class="sidebar-link">类型转换</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/#转boolean" class="sidebar-link">转Boolean</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#对象转基本类型" class="sidebar-link">对象转基本类型</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#四则运算符" class="sidebar-link">四则运算符</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#操作符" class="sidebar-link">== 操作符</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#比较运算符" class="sidebar-link">比较运算符</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/js/#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#new" class="sidebar-link">new</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#instanceof" class="sidebar-link">instanceof</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#this" class="sidebar-link">this</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#执行上下文" class="sidebar-link">执行上下文</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#深浅拷贝" class="sidebar-link">深浅拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/#浅拷贝" class="sidebar-link">浅拷贝</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#深拷贝" class="sidebar-link">深拷贝</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/js/#模块化" class="sidebar-link">模块化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/#commonjs" class="sidebar-link">CommonJS</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#amd" class="sidebar-link">AMD</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/js/#防抖" class="sidebar-link">防抖</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#节流" class="sidebar-link">节流</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#继承" class="sidebar-link">继承</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#call，apply，bind-区别" class="sidebar-link">call，apply，bind 区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/#模拟实现call-和apply" class="sidebar-link">模拟实现call 和apply</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/js/#promise-实现" class="sidebar-link">Promise 实现</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#generator-实现" class="sidebar-link">Generator 实现</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#map、flatmap-和reduce" class="sidebar-link">Map、FlatMap 和Reduce</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#async-和await" class="sidebar-link">async 和await</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#proxy" class="sidebar-link">Proxy</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#为什么0-1-0-2-0-3" class="sidebar-link">为什么0.1 + 0.2 != 0.3</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#正则表达式" class="sidebar-link">正则表达式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/#元字符" class="sidebar-link">元字符</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#修饰语" class="sidebar-link">修饰语</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#字符简写" class="sidebar-link">字符简写</a></li></ul></li><li class="sidebar-sub-header"><a href="/frontend/js/#v8-下的垃圾回收机制" class="sidebar-link">V8 下的垃圾回收机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/js/#准确式gc" class="sidebar-link">准确式GC</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#新生代算法" class="sidebar-link">新生代算法</a></li><li class="sidebar-sub-header"><a href="/frontend/js/#老生代算法" class="sidebar-link">老生代算法</a></li></ul></li></ul></li><li><a href="/frontend/browser/" class="sidebar-link">浏览器</a></li><li><a href="/frontend/performance/" class="sidebar-link">性能</a></li><li><a href="/frontend/safety/" class="sidebar-link">安全</a></li><li><a href="/frontend/framework/" class="sidebar-link">框架通识</a></li><li><a href="/frontend/Vue/" class="sidebar-link">Vue</a></li><li><a href="/frontend/React/" class="sidebar-link">React</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机通识</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js"><a href="#js" aria-hidden="true" class="header-anchor">#</a> JS</h1> <h2 id="内置类型"><a href="#内置类型" aria-hidden="true" class="header-anchor">#</a> 内置类型</h2> <p>JS 中分为七 种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。</p> <p>基本类型有六 种：<code>null</code>，<code>undefined</code>，<code>boolean</code>，<code>number</code>,<code>string</code>,<code>symbol</code>。</p> <p>其中JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于IEEE 754标准实现，在使用中会遇到某些Bug。<code>NaN</code> 也属于 <code>number</code> 类型，并且 <code>NaN</code> 不等于自身。</p> <p>对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Foo'</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> copy <span class="token operator">=</span> obj
copy<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'Bar'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// =&gt; Bar</span>
</code></pre></div><h2 id="typeof"><a href="#typeof" aria-hidden="true" class="header-anchor">#</a> typeof</h2> <p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token number">1</span> <span class="token comment">// =&gt; 'number'</span>
<span class="token keyword">typeof</span> <span class="token string">'1'</span> <span class="token comment">// =&gt; 'string'</span>
<span class="token keyword">typeof</span> <span class="token keyword">undefined</span> <span class="token comment">// =&gt; 'undefined'</span>
<span class="token keyword">typeof</span> <span class="token boolean">true</span> <span class="token comment">// =&gt; 'boolean'</span>
<span class="token keyword">typeof</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 'symbol'</span>
<span class="token keyword">typeof</span> b <span class="token comment">// =&gt; b 没有声明，但是还会显示 undefined</span>
</code></pre></div><p>对于 <code>null</code> 来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 Bug。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token keyword">null</span> <span class="token comment">// =&gt; 'object'</span>
</code></pre></div><p>PS：为什么会出现这种情况呢？因为在JS 的最初版本中，使用的是32 位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code> 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p> <p><code>typeof</code> 对于对象，除了函数都会显示 <code>object</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// =&gt; 'object'</span>
<span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// =&gt; 'object'</span>
<span class="token keyword">typeof</span> console<span class="token punctuation">.</span>log <span class="token comment">// =&gt; 'function'</span>
</code></pre></div><p>如果我们想获得一个变量的正确类型，可以通过 <code>Object.prototype.toString.call()</code> 。这样我们就可以获得类似 <code>[Object Type]</code> 的字符串。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a
<span class="token comment">// 我们也可以这样判断 undefined</span>
a <span class="token operator">===</span> <span class="token keyword">undefined</span>
<span class="token comment">// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span>
<span class="token keyword">let</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token comment">// 这样判断就会出错</span>
<span class="token comment">// 所以可以用下面的方式来判断，并且代码量更少</span>
<span class="token comment">// 因为 void 后面随便跟上一个组成表达式</span>
<span class="token comment">// 返回就是 undefined</span>
a <span class="token operator">===</span> <span class="token keyword">void</span> <span class="token number">0</span>
</code></pre></div><h2 id="类型转换"><a href="#类型转换" aria-hidden="true" class="header-anchor">#</a> 类型转换</h2> <h3 id="转boolean"><a href="#转boolean" aria-hidden="true" class="header-anchor">#</a> 转Boolean</h3> <p>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>''</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象。</p> <h3 id="对象转基本类型"><a href="#对象转基本类型" aria-hidden="true" class="header-anchor">#</a> 对象转基本类型</h3> <p>对象在转换基本类型时，首先会调用 <code>valueOf</code> 然后调用 <code>toString</code>。并且这两个方法你是可以重写的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然你也可以重写 <code>Symbol.toPrimitive</code>, 该方法在转基本类型时调用优先级最高。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>toPrimitive<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token number">1</span> <span class="token operator">+</span> a <span class="token comment">// =&gt; 3</span>
<span class="token string">'1'</span> <span class="token operator">+</span> a <span class="token comment">// =&gt; '12'</span>
</code></pre></div><h3 id="四则运算符"><a href="#四则运算符" aria-hidden="true" class="header-anchor">#</a> 四则运算符</h3> <p>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">1</span> <span class="token operator">+</span> <span class="token string">'1'</span> <span class="token comment">// =&gt; '11'</span>
<span class="token number">2</span> <span class="token operator">*</span> <span class="token string">'2'</span> <span class="token comment">// =&gt; 4</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token comment">// =&gt; '1,22,1'</span>
<span class="token comment">// [1, 2].toString()   =&gt; '1,2'</span>
<span class="token comment">// [2, 1].toString()   =&gt; '2,1'</span>
<span class="token comment">// '1,2' + '2,1' = '1,22,1'</span>
</code></pre></div><p>对于加号需要注意这个表达式 <code>'a' + + 'b'</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">'a'</span> <span class="token operator">+</span> <span class="token operator">+</span> <span class="token string">'b'</span>  <span class="token comment">// =&gt; 'aNaN'</span>
<span class="token comment">// 因为 + 'b' =&gt; NaN</span>
<span class="token comment">// 你也许在一些代码中看到过 + '1' =&gt; 1</span>
</code></pre></div><h3 id="操作符"><a href="#操作符" aria-hidden="true" class="header-anchor">#</a> == 操作符</h3> <p><img src="/frontend/assets/img/0.f205c34f.png" alt="== operator"></p> <p>上图中的 <code>toPrimitive</code> 就是对象转基本类型。</p> <p>这里来解析一道题目 <code>[] == ![] // =&gt; true</code>，下面就是这个表达式为何为 <code>true</code> 的步骤</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// [] 转成 true， 然后取反变成 false</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span>
<span class="token comment">// 根据第 8 条得出</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token function">ToNumber</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token comment">// 根据第 10 条得出</span>
<span class="token function">ToPrimitive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token comment">// [].toString() // =&gt; ''</span>
<span class="token string">''</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token comment">// 根据第 6 条得出</span>
<span class="token number">0</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token comment">// =&gt; true</span>
</code></pre></div><h3 id="比较运算符"><a href="#比较运算符" aria-hidden="true" class="header-anchor">#</a> 比较运算符</h3> <ol><li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li> <li>如果是字符串，就通过 <code>unicode</code>  字符索引来比较</li></ol> <h2 id="原型"><a href="#原型" aria-hidden="true" class="header-anchor">#</a> 原型</h2> <p><img src="/frontend/assets/img/1.56648df6.jpg" alt="prototype">
图片来自：http://www.mollypages.org/tutorials/js.mp</p> <p>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>, 该属性指向原型。</p> <p>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code> ，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问，所以使用 <code>__proto__</code> 来访问。</p> <p>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性， <code>__proto__</code> 将对象链接起来组成了原型链。</p> <p>如果你想更进一步的了解原型，可以仔细阅读<a href="https://github.com/KieSun/Dream/issues/2" target="_blank" rel="noopener noreferrer">深度解析原型中的各个难点<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <h2 id="new"><a href="#new" aria-hidden="true" class="header-anchor">#</a> new</h2> <ol><li>新生成了一个对象</li> <li>链接到原型</li> <li>绑定this，执行构造函数</li> <li>返回新对象</li></ol> <p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个空对象</span>
  <span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 获得构造函数</span>
  <span class="token keyword">let</span> Con <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
  <span class="token comment">// 链接到原型</span>
  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token class-name">Con</span><span class="token punctuation">.</span>prototype
  <span class="token comment">// 绑定 this， 执行构造函数</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">Con</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
  <span class="token comment">// 确保 new 出来的是个对象</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> obj
<span class="token punctuation">}</span>
</code></pre></div><p>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p> <p>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// function 就是个语法糖</span>
<span class="token comment">// 内部等同于 new Function()</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token comment">// 这个字面量内部也是使用了 new Object()</span>
</code></pre></div><p>对于 <code>new</code> 来说，还需要注意下运算符优先级。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>

Foo<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Foo<span class="token punctuation">.</span>getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 1</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// =&gt; 2</span>
</code></pre></div><p><img src="/frontend/assets/img/2.f58bc331.png" alt="precedence operator"></p> <p>从上图可以看出， <code>new Foo()</code> 的优先级大于 <code>new Foo</code> ，所以对于上述代码来说可以这样划分执行顺序</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>对于第一个函数来说，先执行了 <code>Foo.getName()</code> ， 所以结果为 1；对于后者来说，先执行 <code>new Foo()</code> 产生了一个实例，然后通过原型链找到了 <code>Foo</code> 上的 <code>getName</code> 函数，所以结果为 2。</p> <h2 id="instanceof"><a href="#instanceof" aria-hidden="true" class="header-anchor">#</a> instanceof</h2> <p><code>instanceof</code> 可以正确地判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p> <p>我们也可以试着实现一个 <code>instanceof</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">instanceof</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 获得类型的原型</span>
  <span class="token keyword">let</span> prototype <span class="token operator">=</span> right<span class="token punctuation">.</span>prototype
  <span class="token comment">// 获得对象的原型</span>
  left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__
  <span class="token comment">// 判断对象的类型是否等于类型的原型</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prototype <span class="token operator">===</span> left<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
    left <span class="token operator">=</span> left<span class="token punctuation">.</span>__proto__
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h2> <p><code>this</code> 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就可以了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  foo<span class="token punctuation">:</span> foo
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个大于第一个情况</span>


<span class="token comment">// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>a<span class="token punctuation">)</span>

<span class="token comment">// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new</span>
</code></pre></div><p>以上几种情况明白了，很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code> 。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是 <code>window</code>。并且 <code>this</code> 一旦绑定了上下文，就不会被任何代码改变。</p> <h2 id="执行上下文"><a href="#执行上下文" aria-hidden="true" class="header-anchor">#</a> 执行上下文</h2> <p>当执行 JS 代码时，会产生三种执行上下文</p> <ul><li>全局执行上下文</li> <li>函数执行上下文</li> <li>eval 执行上下文</li></ul> <p>每个执行上下文中都有三个属性</p> <ul><li>变量对象（ VO ），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li> <li>作用域链（ JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了）</li> <li>this</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span>
<span class="token punctuation">}</span> 
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>对于上述代码，执行栈中有两个上下文：全局上下文和函数 <code>foo</code> 上下文。</p> <div class="language-js extra-class"><pre class="language-js"><code>stack <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext<span class="token punctuation">,</span>
  fooContext
<span class="token punctuation">]</span>
</code></pre></div><p>对于全局上下文来说，VO 大概是这样的</p> <div class="language-js extra-class"><pre class="language-js"><code>globalContext<span class="token punctuation">.</span><span class="token constant">VO</span> <span class="token operator">===</span> global
globalContext<span class="token punctuation">.</span><span class="token constant">VO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  foo<span class="token punctuation">:</span> <span class="token operator">&lt;</span>Function<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对于函数 <code>foo</code> 来说，VO 不能访问，只能访问到活动对象（ AO ）</p> <div class="language-js extra-class"><pre class="language-js"><code>fooContext<span class="token punctuation">.</span><span class="token constant">VO</span> <span class="token operator">===</span> foo<span class="token punctuation">.</span><span class="token constant">AO</span>
fooContext<span class="token punctuation">.</span><span class="token constant">AO</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  i<span class="token punctuation">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  arguments<span class="token punctuation">:</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
<span class="token comment">// arguments 是函数独有的对象（箭头函数没有）</span>
<span class="token comment">// 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素</span>
<span class="token comment">// 该对象中的 `callee` 代表函数本身</span>
<span class="token comment">// `caller` 属性代表函数的调用者</span>
</code></pre></div><p>对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 <code>[[Scope]]</code> 属性查找上级变量</p> <div class="language-js extra-class"><pre class="language-js"><code>fooContext<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span>
<span class="token punctuation">]</span>
fooContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> fooContext<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> fooContext<span class="token punctuation">.</span><span class="token constant">VO</span>
fooContext<span class="token punctuation">.</span>Scope <span class="token operator">=</span> <span class="token punctuation">[</span>
  fooContext<span class="token punctuation">.</span><span class="token constant">VO</span><span class="token punctuation">,</span>
  globalContext<span class="token punctuation">.</span><span class="token constant">VO</span>
<span class="token punctuation">]</span>
</code></pre></div><p>接下来让我们看一个老生常谈的例子，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; call b</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">//=&gt; undefined</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'Hello world'</span>

<span class="token keyword">function</span> <span class="token function">b</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call b'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上的输出大家都已经明白了，这是因为函数和变量提升的问题。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO ），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</p> <p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// =&gt; call b second</span>

<span class="token keyword">function</span> <span class="token function">b</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call b first'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">b</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call b second'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">'Hello world'</span>
</code></pre></div><p><code>var</code> 会产生很多错误，所以在 ES6 中引入了 <code>let</code> 。 <code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升， <code>let</code> 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。</p> <p>对于非匿名的立即执行函数需要注意一下一点</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  foo <span class="token operator">=</span> <span class="token number">10</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; f foo() { foo = 10 ; console.log(foo)}</span>
</code></pre></div><p>因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code> , 但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p> <div class="language-js extra-class"><pre class="language-js"><code>specialObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Scope <span class="token operator">=</span> specialObject <span class="token operator">+</span> Scope

foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FunctionExpression</span>
foo<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">[</span>Scope<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> Scope
specialObject<span class="token punctuation">.</span>foo <span class="token operator">=</span> foo <span class="token comment">// {DontDelete}, {ReadOnly}</span>

<span class="token keyword">delete</span> Scope<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment">// remove specialObject from the front of scope chain</span>
</code></pre></div><h2 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h2> <p>闭包的定义很简单：函数 A 返回了一个函数 B , 并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token constant">A</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">function</span> <span class="token constant">B</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token constant">B</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你是否会疑惑，为什么函数 A 已经弹出调用栈了， 为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p> <p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。</p> <p>解决办法，第一种使用闭包</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> j<span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>第二种就是使用 <code>setTimeout</code> 的第三个参数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i<span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token comment">// 形成块级作用域</span>
  <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ii <span class="token operator">=</span> i
    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      consoe<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ii<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> ii<span class="token operator">*</span><span class="token number">1000</span> <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  i <span class="token operator">++</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ii <span class="token operator">=</span> i
  <span class="token punctuation">}</span>
  i <span class="token operator">++</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ii <span class="token operator">=</span> i
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="深浅拷贝"><a href="#深浅拷贝" aria-hidden="true" class="header-anchor">#</a> 深浅拷贝</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> a
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// =&gt; 2</span>
</code></pre></div><p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变</p> <p>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p> <h3 id="浅拷贝"><a href="#浅拷贝" aria-hidden="true" class="header-anchor">#</a> 浅拷贝</h3> <p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// =&gt; 1</span>
</code></pre></div><p>当然我们也可以通过展开运算符（<code>...</code>） 来解决</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>a<span class="token punctuation">}</span>
a<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">2</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// =&gt; 1</span>
</code></pre></div><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">...</span>a<span class="token punctuation">}</span>
a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment">// =&gt; native</span>
</code></pre></div><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</p> <h3 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h3> <p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  jobs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    first<span class="token punctuation">:</span> <span class="token string">'FE'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
a<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token string">'native'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>jobs<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token comment">// =&gt; FE</span>
</code></pre></div><p>但是该方法也是有局限性的：</p> <ul><li>会忽略 <code>undefined</code></li> <li>会忽略 <code>symbol</code></li> <li>不能序列化函数</li> <li>不能解决循环引用的问题</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    d<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>b
obj<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>a
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> obj<span class="token punctuation">.</span>c
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>d <span class="token operator">=</span> obj<span class="token punctuation">.</span>b
obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>e <span class="token operator">=</span> obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c
<span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span>
</code></pre></div><p>如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝
<img src="data:image/png;base64,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" alt="Uncaught TypeError"></p> <p>在遇到函数、<code>undefined</code> 或者 <code>symbol</code> 的时候，该对象也不能正常的序列化</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
  age<span class="token punctuation">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  sex<span class="token punctuation">:</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'male'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function-variable function">jobs</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">'foo'</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// =&gt; {name: 'foo'}</span>
</code></pre></div><p>你会发现在上述情况中，该方法会忽略掉函数、 <code>undefined</code> 和 <code>symbol</code> 。</p> <p>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 <a href="https://lodash.com/docs##cloneDeep" target="_blank" rel="noopener noreferrer">lodash 的深拷贝函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 <code>MessageChannel</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">structuralClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span>port1<span class="token punctuation">,</span> port2<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    port2<span class="token punctuation">.</span><span class="token function-variable function">onmessage</span> <span class="token operator">=</span> <span class="token parameter">ev</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    port1<span class="token punctuation">.</span><span class="token function">postMessage</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">:</span> b
<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token comment">// 注意该方法是异步的</span>
<span class="token comment">// 可以处理 undefined 和循环引用对象</span>
<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> clone <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">structuralClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="模块化"><a href="#模块化" aria-hidden="true" class="header-anchor">#</a> 模块化</h2> <p>在有 Babel 的情况下，我们可以直接使用 ES6 的模块化</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// file a.js</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">b</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// file b.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span>a<span class="token punctuation">,</span> b<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./a.js'</span>
<span class="token keyword">import</span> <span class="token constant">XX</span> <span class="token keyword">from</span> <span class="token string">'./b.js'</span>
</code></pre></div><h3 id="commonjs"><a href="#commonjs" aria-hidden="true" class="header-anchor">#</a> CommonJS</h3> <p><code>CommonJs</code> 是 Node 独有的规范，浏览器中使用就需要用到 <code>Browserify</code> 解析了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// a.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment">// or</span>
exports<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token comment">// b.js</span>
<span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>a  <span class="token comment">// =&gt; 1</span>
</code></pre></div><p>在上述代码中， <code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a.js'</span><span class="token punctuation">)</span>
module<span class="token punctuation">.</span>a
<span class="token comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span>
<span class="token comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基本实现</span>
<span class="token keyword">var</span> module <span class="token operator">=</span> <span class="token punctuation">{</span>
  exports<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// exports 就是个空对象</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span>
<span class="token keyword">var</span> exports <span class="token operator">=</span> module<span class="token punctuation">.</span>exports
<span class="token keyword">var</span> <span class="token function-variable function">load</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 导出的东西</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    module<span class="token punctuation">.</span>exports <span class="token operator">=</span> a
    <span class="token keyword">return</span> module<span class="token punctuation">.</span>exports
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>再来说说 <code>module.exports</code> 和 <code>exports</code>，用法其实是相似的，但是不能对 <code>exports</code> 直接赋值，不会有任何效果。</p> <p>对于 <code>CommonJS</code> 和 ES6 中的模块化的两者区别是：</p> <ul><li>前者支持动态导入，也就是 <code>require(${path}/xx.js)</code> ，后者目前不支持，但是已有提案</li> <li>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程响应也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li> <li>前者在导出是都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入因此。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li> <li>后者会编译成 <code>require/exports</code> 来执行的</li></ul> <h3 id="amd"><a href="#amd" aria-hidden="true" class="header-anchor">#</a> AMD</h3> <p>AMD 是由 <code>RequireJS</code> 提出的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// AMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./a'</span><span class="token punctuation">,</span> <span class="token string">'./b'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">.</span><span class="token function">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  b<span class="token punctuation">.</span><span class="token function">do</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exports<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./a'</span><span class="token punctuation">)</span>
  a<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./b'</span><span class="token punctuation">)</span>
  b<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="防抖"><a href="#防抖" aria-hidden="true" class="header-anchor">#</a> 防抖</h2> <p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p> <p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p> <p>PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数间隔小于 wait , 防抖的情况下只会调用一次，而节流的情况会每隔一定事件（参数 wait ） 调用函数。</p> <p>我们先来看一个袖珍版的防抖理解一下防抖的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// func 是用户传入需要防抖的函数</span>
<span class="token comment">// wait 是等待时间</span>
<span class="token keyword">const</span> <span class="token function-variable function">debounce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// 缓存一个定时器</span>
  <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 这里返回的函数是每次用户实际调用的防抖函数</span>
  <span class="token comment">// 如果已经设置过定时器就清空上一次的定时器</span>
  <span class="token comment">// 开始一个新的定时器，延迟执行用户传入的方法</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 不难看出如果用户调用该函数的间隔小于wait 的情况下，上一次的时间还未到就被清楚了，并不会执行函数</span>
</code></pre></div><p>这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有 immediate 选项，表示是否立即调用。这两者的区别，举个例子来说：</p> <ul><li>例如在搜索引擎搜索问题的时候，我们当然希望用户输入完最后一个字才调用查询接口，这个时候适用 <code>延迟执行</code> 的防抖函数，它总是在一连串（间隔小于 wait 的）函数触发之后调用。</li> <li>例如用户给 frontend 点 star 的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变 star 的样式，用户就可以立即得到反馈是否 star 成功了，这个情况适用 <code>立即执行</code> 的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的事件间隔大于 wait 才会触发。</li></ul> <p>下面我们来实现一个带有 <code>立即执行</code> 选项的防抖函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 这个是用来获取当前时间戳的</span>
<span class="token keyword">function</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 防抖函数，返回函数连续调用时，空闲时间必须大于等于 wait，func 才会执行
 * 
 * @param {function} func 回调函数 
 * @param {number} wait 表示时间窗口的时间
 * @param {boolean} immediate  设置会true 时，是否立即调用函数
 * @returns {function} 返回客户调用哈函数
 */</span>
<span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">,</span> immediate <span class="token operator">=</span> <span class="token boolean">true</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer<span class="token punctuation">,</span> context<span class="token punctuation">,</span> args

  <span class="token comment">// 延迟执行函数</span>
  <span class="token keyword">const</span> <span class="token function-variable function">later</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 延迟函数执行完毕，清空缓存的定时器序号</span>
    timer <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token comment">// 延迟执行的情况下，函数会在延迟函数中执行</span>
    <span class="token comment">// 使用到之前缓存的参数和上下文</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> wait<span class="token punctuation">)</span>

  <span class="token comment">// 这里返回的函数必须是每次实际调用的函数</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果没有创建延迟执行函数（later），就创建一个</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">later</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 如果是立即执行，调用函数</span>
      <span class="token comment">// 否则缓存参数和调用上下文</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>immediate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        context <span class="token operator">=</span> <span class="token keyword">this</span>
        args <span class="token operator">=</span> params
      <span class="token punctuation">}</span>

      <span class="token comment">// 如果已有延迟执行函数（later），调用的时候清除原来的并重新设置一个</span>
      <span class="token comment">// 这样做延迟函数会重新计时</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
      timer <span class="token operator">=</span> <span class="token function">later</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>整体函数实现的不难，总结一下。</p> <ul><li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我们开始一个定时器，只要我的定时器还在，你每次点击我动重新计时。一旦你点击累了，定时器时间到，函数执行，定时器重置为 <code>null</code> ,就可以再次点击了。</li> <li>对于延迟执行函数来说的实现：清除定时器 ID，如果是延迟调用就调用函数</li></ul> <h2 id="节流"><a href="#节流" aria-hidden="true" class="header-anchor">#</a> 节流</h2> <p>防抖和节流本质是不一样的。防抖是将多次执行变为最后因此执行，节流是将多次执行变成每隔一段时间执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait
 * 
 * @param {function} func 回调函数
 * @param {number} wait 表示时间窗口的间隔
 * @param {object} options 如果想忽略开始函数的调用，传入{leading: false}
 *                         如果想忽略结尾函数的调用，传入{trailing: false}
 *                         两者不能共存，否则函数不能执行
 * @returns {function} 返回客户调用函数
 */</span>
_<span class="token punctuation">.</span><span class="token function-variable function">throttle</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">func<span class="token punctuation">,</span> wait<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> context<span class="token punctuation">,</span> args<span class="token punctuation">,</span> result
  <span class="token keyword">var</span> timeout <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token comment">// 之前的时间戳</span>
  <span class="token keyword">var</span> previous <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token comment">// 如果 options 没传则设置为空对象</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>options<span class="token punctuation">)</span> options <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 定时器回调函数</span>
  <span class="token keyword">var</span> <span class="token function-variable function">later</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果设置了 leading， 就将 previous 设为 0</span>
    <span class="token comment">// 用于下面函数的第一个 if 判断</span>
    previous <span class="token operator">=</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 置空，亦是为了防止内存泄漏，二是为了下面的定时器判断</span>
    timeout <span class="token operator">=</span> <span class="token keyword">null</span>
    result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 获得当前时间戳</span>
    <span class="token keyword">var</span> now <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 首次进入前者肯定为 true</span>
    <span class="token comment">// 如果需要第一次不执行函数</span>
    <span class="token comment">// 就将上次时间戳设为当前的</span>
    <span class="token comment">// 这样在接下来计算 remaining 的值时会大于 0 </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>previous <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>leading <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> previous <span class="token operator">=</span> now
    <span class="token comment">// 计算剩余时间</span>
    <span class="token keyword">var</span> remaining <span class="token operator">=</span> wait <span class="token operator">-</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> previous<span class="token punctuation">)</span>
    context <span class="token operator">=</span> <span class="token keyword">this</span>
    args <span class="token operator">=</span> arguments
    <span class="token comment">// 如果当前调用已经大于上次调用时间 + wait </span>
    <span class="token comment">// 或者用户手动调了时间</span>
    <span class="token comment">// 如果设置了 trailing，只会进入这个条件</span>
    <span class="token comment">// 如果没有设置 leading，那么第一次会进入这个条件</span>
    <span class="token comment">// 还有一点，你可以会觉得开启了定时器那么应该不会进入这个 if 条件了</span>
    <span class="token comment">// 其实还是会进入的，因为定时器的延时</span>
    <span class="token comment">// 并不是准确的时间，很可能你设置了 2 秒</span>
    <span class="token comment">// 但他需要 2.2 秒才触发，这时候就会进入这个条件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> remaining <span class="token operator">&gt;</span> wait<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果存在定时器就清理掉否则会调用二次回调</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
        timeout <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span>
      previous <span class="token operator">=</span> now
      result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout<span class="token punctuation">)</span> context <span class="token operator">=</span> args <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timeout <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>trailing <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 判断是否设置了定时器和 trailing</span>
      <span class="token comment">// 没有的话就开启一个定时器</span>
      <span class="token comment">// 并且不能同时设置 leading 和 trailing</span>
      timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>later<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> timeout
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="继承"><a href="#继承" aria-hidden="true" class="header-anchor">#</a> 继承</h2> <p>在 ES5 中，我们可以使用如下方式解决继承的问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getNumber</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span>
<span class="token punctuation">}</span>


<span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token class-name">Sub</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Super</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  value<span class="token punctuation">:</span> Sub<span class="token punctuation">,</span>
  emumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  configurable<span class="token punctuation">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>以上继承实现思路就是将子类的原型设置为父类的原型</p> <p>在 ES6 中，我们可以通过 <code>class</code> 语法轻松解决这个问题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyDate</span> <span class="token keyword">extends</span> <span class="token class-name">Date</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    reutrn <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> myDate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
myDate<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>但是 ES6 不是所有浏览器都兼容，所以我们需要使用 Babel 来编译这段代码。</p> <p>如果你使用编译过得代码调用 <code>myDate.test()</code> 你会惊奇地发现出现了报错</p> <p>因为在 JS 底层有限制，如果不是由 <code>Date</code> 构造出来的实例的话，是不能调用 <code>Date</code> 里的函数的。所以这也侧面的说明了：<strong>ES6 中的 <code>class</code> 继承与 ES5 中的一般继承写法是不同的</strong>。</p> <p>既然底层限制了实例必须由 <code>Date</code> 构造出来，那么我们可以改变下思路实现继承</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">MyDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">MyDate</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token class-name">MyDate</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">MyDate</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">Date</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
</code></pre></div><p>以上继承实现思路：<strong>先创建父类实例</strong> =&gt; 改变实例原先的 <code>__proto__</code> 转而连接到子类的 <code>prototype</code>  =&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</p> <p>通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。</p> <h2 id="call，apply，bind-区别"><a href="#call，apply，bind-区别" aria-hidden="true" class="header-anchor">#</a> call，apply，bind 区别</h2> <p>首先说下前两者的区别。</p> <p><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p> <p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>
    value<span class="token punctuation">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token string">'Foo'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">)</span>
<span class="token function">getValue</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'Foo'</span><span class="token punctuation">,</span> <span class="token string">'18'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="模拟实现call-和apply"><a href="#模拟实现call-和apply" aria-hidden="true" class="header-anchor">#</a> 模拟实现call 和apply</h3> <p>可以从以下几点来考虑如何实现</p> <ul><li>不传入第一个参数，那么默认为 <code>window</code></li> <li>改变了 this 指向，让新的对象可以执行该函数。那么思路是可以变成给新的对象添加一个函数，然后在执行完以后删除？</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myCall</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> context <span class="token operator">=</span> context <span class="token operator">||</span> window
  <span class="token comment">// 给 context 添加一个属性</span>
  <span class="token comment">// getValue.call(a, 'Foo', '18') =&gt; a.fn = getValue</span>
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token comment">// 将 context 后面的参数取出来</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment">// getValue.call(a, 'Foo', '18') =&gt; a.fn('Foo', '18')</span>
  <span class="token keyword">var</span> result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
  <span class="token comment">// 删除 fn</span>
  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p>以上就是 <code>call</code> 的思路， <code>apply</code> 的实现也类似</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myApply</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> context <span class="token operator">=</span> context <span class="token operator">||</span> window
  context<span class="token punctuation">.</span>fn <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">var</span> result
  <span class="token comment">// 需要判断是否存在第二个参数</span>
  <span class="token comment">// 如果存在，就将第二个参数展开</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    result <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">delete</span> context<span class="token punctuation">.</span>fn
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span>
</code></pre></div><p><code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 <code>bind</code> 实现柯里化。</p> <p>同样的，也来模拟实现下 <code>bind</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token comment">// 返回一个函数</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 因为返回了一个函数，我们可以 new F(), 所以需要判断</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">_this</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">_this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="promise-实现"><a href="#promise-实现" aria-hidden="true" class="header-anchor">#</a> Promise 实现</h2> <p><code>Promise</code> 是 ES6 新增的语法，解决了回调地狱的问题。</p> <p>可以把 <code>Promise</code> 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code> ，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</p> <p><code>then</code> 函数会返回一个 <code>Promise</code> 实例，并且该返回值是一个新的实例而不是之前的实例。因为 <code>Promise</code> 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code> 调用就失去意义了。</p> <p>对于 <code>then</code> 来说，本质上可以把它看成是 <code>flatMap</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 三种状态</span>
<span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>
<span class="token keyword">const</span> <span class="token constant">RESOLVED</span> <span class="token operator">=</span> <span class="token string">'ressolved'</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>
<span class="token comment">// promise 接收一个函数参数，该函数立即执行</span>
<span class="token keyword">function</span> <span class="token function">MyPromise</span> <span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
  _this<span class="token punctuation">.</span>currentState <span class="token operator">=</span> <span class="token constant">PENDING</span>
  _this<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">undefined</span>
  <span class="token comment">// 用于保存 then 中的回调，只有当 promise</span>
  <span class="token comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span>
  _this<span class="token punctuation">.</span>resvoledCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  _this<span class="token punctuation">.</span>rejectedCallbacks <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

  _this<span class="token punctuation">.</span><span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果 value 是个 Promise，递归执行</span>
      <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>_this<span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> _this<span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 异步执行，保证执行顺序</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>_this<span class="token punctuation">.</span>currentState <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        _this<span class="token punctuation">.</span>currentState <span class="token operator">=</span> <span class="token constant">RESOLVED</span>
        _this<span class="token punctuation">.</span>value <span class="token operator">=</span> value
        _this<span class="token punctuation">.</span>resvoledCallbacks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">cb</span> <span class="token operator">=&gt;</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 用于解决以下问题</span>
  <span class="token comment">// new Promise(() =&gt; throw Error('error'))</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span>_this<span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> _this<span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _this<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">MyPromise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">onResolved<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span>
  <span class="token comment">// 规范 2.2.7 必须返回一个新的 promise</span>
  <span class="token keyword">var</span> promise2
  <span class="token comment">// 规范 2.2 onResolved 和 onRejected 都为可选参数</span>
  <span class="token comment">// 如果类型不是函数需要忽略，同时也实现了透传</span>
  <span class="token comment">// Promise.resolve(4).then().then((value) =&gt; console.log(value))</span>
  onResolved <span class="token operator">=</span> <span class="token keyword">typeof</span> onResolved <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function-variable function">onResolved</span> <span class="token punctuation">:</span> <span class="token parameter">v</span> <span class="token operator">=&gt;</span> v
  onRejected <span class="token operator">=</span> <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function-variable function">onRejected</span> <span class="token punctuation">:</span> <span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token keyword">throw</span> r

  <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>currentState <span class="token operator">===</span> <span class="token constant">RESOLVED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 规范 2.2.4，保证 onFullfiled, onRejected 异步执行</span>
      <span class="token comment">// 所以用 setTimeout 包裹下</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">onResolved</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
          <span class="token function">resolutionProcedure</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>currentState <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 异步执行 onRejected</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
          <span class="token function">resolutionProcedure</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>currentState <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>promise2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      self<span class="token punctuation">.</span>resvoledCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 考虑到可能会报错，所以使用 try/catch 包裹</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">onResolved</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
          <span class="token function">resolutionProcedure</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>

      self<span class="token punctuation">.</span>rejectedCallbacks<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 考虑到可能会报错，所以使用 try/catch 包裹</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token function">onRejected</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
          <span class="token function">resolutionProcedure</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 规范 2.3</span>
<span class="token keyword">function</span> <span class="token function">resolutionProcedure</span><span class="token punctuation">(</span><span class="token parameter">promise2<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise2 <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 规范 2.3.2</span>
  <span class="token comment">// 如果 x 为 Promise， 状态为 pending 需要继续等待，否则执行</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>currentState <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 再次调用该函数是为了确认 x resolve 的</span>
        <span class="token comment">// 参数是什么类型，如果是基本类型就再次 resolve</span>
        <span class="token comment">// 把值传给下个 then</span>
        <span class="token function">resolutionProcedure</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> value<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>      
      <span class="token punctuation">}</span><span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 规范 2.3.3</span>
  <span class="token comment">// reject 或者 resolve 其中一个执行过的话，忽略其他的</span>
  <span class="token keyword">let</span> called <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token comment">// 规范 2.3.3，判断 x 是否为对象后者函数</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 规范 2.3.3.2，如果不能取出 then ，就 reject</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// 规范 2.3.3.1</span>
      <span class="token keyword">let</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then
      <span class="token comment">// 如果 then 是函数，调用 x.then</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 规范 2.3.3.3</span>
        <span class="token function">then</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>
          x<span class="token punctuation">,</span>
          <span class="token parameter">y</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span>
            called <span class="token operator">=</span> <span class="token boolean">true</span>
            <span class="token comment">// 规范 2.3.3.3.1</span>
            <span class="token function">resolutionProcedure</span><span class="token punctuation">(</span>promise2<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span>
          <span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span>
            called <span class="token operator">=</span> <span class="token boolean">true</span>
            <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 规范 2.3.3.4</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>reason<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>called<span class="token punctuation">)</span> <span class="token keyword">return</span>
      called <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>rease<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 规范 2.3.4，x 为基本类型</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上就是根据 Promise / A+ 规范来实现的代码，可以通过 <code>promises-aplus-tests</code> 的完整测试</p> <h2 id="generator-实现"><a href="#generator-实现" aria-hidden="true" class="header-anchor">#</a> Generator 实现</h2> <p>Generator 是 ES6 中新增语法，和 Promise 一样，都可以用来异步编程</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用 * 表示这是一个 Generator 函数</span>
<span class="token comment">// 内部可以通过 yield 暂停代码</span>
<span class="token comment">// 通过调用 next 恢复执行</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span>
  <span class="token keyword">yield</span> <span class="token number">2</span>
  <span class="token keyword">yield</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; { value: 2, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; { value: 3, done: false}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// =&gt; { value: undefined, done: true}</span>
</code></pre></div><p>从以上代码可以发现，加上 <code>*</code> 的函数执行后有了 <code>next</code> 函数，也就说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是Generator 函数的简单实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// cb 也就是编译过的 test 函数</span>
<span class="token keyword">function</span> <span class="token function">generator</span> <span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> object <span class="token operator">=</span> <span class="token punctuation">{</span>
      next<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
      <span class="token function-variable function">stop</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">next</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">cb</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span> value<span class="token punctuation">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> done<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
          value<span class="token punctuation">:</span> ret<span class="token punctuation">,</span>
          done<span class="token punctuation">:</span> <span class="token boolean">false</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span>
<span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> a
  <span class="token keyword">return</span> <span class="token function">generator</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">_context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>_context<span class="token punctuation">.</span>prev <span class="token operator">=</span> _context<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 可以发现通过 yield 将代码分割成几块</span>
        <span class="token comment">// 每次执行 next 函数就执行一块代码</span>
        <span class="token comment">// 并且表明下次需要执行哪块代码</span>
        <span class="token keyword">case</span> <span class="token number">0</span><span class="token punctuation">:</span>
          a <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span>
          _context<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token number">4</span>
          <span class="token keyword">return</span> <span class="token number">2</span>
        <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span>
          _content<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token number">6</span>
          <span class="token keyword">return</span> <span class="token number">3</span>
        <span class="token comment">// 执行完毕  </span>
        <span class="token keyword">case</span> <span class="token number">6</span><span class="token punctuation">:</span>
        <span class="token keyword">case</span> <span class="token string">'end'</span><span class="token punctuation">:</span>
          <span class="token keyword">return</span> _context<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="map、flatmap-和reduce"><a href="#map、flatmap-和reduce" aria-hidden="true" class="header-anchor">#</a> Map、FlatMap 和Reduce</h2> <p><code>Map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 <code>append</code> 到新的数组中。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; [2, 3, 4]</span>
</code></pre></div><p><code>Map</code> 有三个参数，分别是当前索引元素，索引，原数组</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token string">'1'</span><span class="token punctuation">,</span><span class="token string">'2'</span><span class="token punctuation">,</span><span class="token string">'3'</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>parseInt<span class="token punctuation">)</span>
<span class="token comment">//  parseInt('1', 0) =&gt; 1</span>
<span class="token comment">//  parseInt('2', 1) =&gt; NaN</span>
<span class="token comment">//  parseInt('3', 2) =&gt; NaN</span>
</code></pre></div><p><code>FlatMap</code> 和 <code>map</code> 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 <code>FlatMap</code> 看成是 <code>map</code> + <code>flatten</code> ，目前该函数在浏览器中还不支持。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; [2, 3, 4]</span>
</code></pre></div><p>如果想将一个多维数组彻底的降维，可以这样实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">flattenDeep</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
  <span class="token operator">?</span> arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token operator">...</span>a<span class="token punctuation">,</span> <span class="token operator">...</span><span class="token function">flattenDeep</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">:</span> <span class="token punctuation">[</span>arr<span class="token punctuation">]</span>

<span class="token function">flattenDeep</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p><code>Reduce</code> 作用是数组中的值组合起来，最终得到一个值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// =&gt; 2 1</span>
</code></pre></div><h2 id="async-和await"><a href="#async-和await" aria-hidden="true" class="header-anchor">#</a> async 和await</h2> <p>一个函数加上 <code>async</code> ，内码该函数就会返回一个 <code>Promise</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token string">&quot;1&quot;</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; Promise {&lt;resolved&gt;: &quot;1&quot;}</span>
</code></pre></div><p>可以把 <code>async</code> 看成函数返回值使用 <code>Promise.resolve()</code> 包裹了下。</p> <p><code>await</code> 只能在 <code>async</code> 函数中使用</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">sleep</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'finish'</span><span class="token punctuation">)</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'sleep'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'object'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行通过代码再来执行异步代码。</p> <p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步diam并不依赖前者，但仍然需要等待前者完成，导致代码失去了并发性。</p> <p>下面来看一个使用 <code>await</code> 的代码</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">var</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token keyword">await</span> <span class="token number">10</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>   <span class="token comment">// =&gt; '2' 10</span>
  a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">+</span> a
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>   <span class="token comment">// =&gt; '3' 20</span>
<span class="token punctuation">}</span>
<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
a <span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>  <span class="token comment">// =&gt; '1' 1</span>
</code></pre></div><p>对于以上代码你可能会有疑惑，这里说明下原理</p> <ul><li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0， 因为在 <code>await</code> 内部实现了 <code>generators</code> , <code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li> <li>因为 <code>await</code> 是异步操作，遇到 <code>await</code> 就会立即返回一个 <code>pending</code> 状态的 <code>Promise</code> 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log('1', a)</code></li> <li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来用，这时候 <code>a = 10</code></li> <li>然后后面就是常规执行代码了</li></ul> <h2 id="proxy"><a href="#proxy" aria-hidden="true" class="header-anchor">#</a> Proxy</h2> <p>Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token comment">// 'target' 代表需要添加代理的对象</span>
<span class="token comment">// `handler` 用来自定义对象中的操作</span>
</code></pre></div><p>可以很方便的使用 Proxy 来实现一个数据版定和监听</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">onWatch</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> setBind<span class="token punctuation">,</span> getLogger</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">getLogger</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">)</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setBind</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> property<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> value 
<span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token function">onWatch</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token parameter">v</span><span class="token operator">=&gt;</span>value <span class="token operator">=</span> v<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> property</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Get '</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>property<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">' = </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>target<span class="token punctuation">[</span>property<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span>  <span class="token comment">// bind `value` to `2`</span>
p<span class="token punctuation">.</span>a      <span class="token comment">// =&gt; Get 'a' = 2</span>
</code></pre></div><h2 id="为什么0-1-0-2-0-3"><a href="#为什么0-1-0-2-0-3" aria-hidden="true" class="header-anchor">#</a> 为什么0.1 + 0.2 != 0.3</h2> <p>因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。</p> <p>我们都知道计算机表示十进制都是采用二进制表示的，所以 <code>0.1</code> 在二进制表示为</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// (0011) 表示循环</span>
<span class="token number">0.1</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">^</span><span class="token operator">-</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1.1001</span><span class="token punctuation">(</span><span class="token number">0011</span><span class="token punctuation">)</span>
</code></pre></div><p>那么如何得到这个二进制的呢？我们可以来演算下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.1</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0.2</span> <span class="token comment">// 0</span>
<span class="token number">0.2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0.4</span> <span class="token comment">// 0</span>
<span class="token number">0.4</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0.8</span> <span class="token comment">// 0</span>
<span class="token number">0.8</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1.6</span> <span class="token comment">// 1</span>
<span class="token number">0.6</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1.2</span> <span class="token comment">// 1</span>
<span class="token number">0.2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0.4</span> <span class="token comment">// 0</span>
<span class="token number">0.4</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0.8</span> <span class="token comment">// 0</span>
<span class="token number">0.8</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1.6</span> <span class="token comment">// 1</span>
<span class="token number">0.6</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1.2</span> <span class="token comment">// 1</span>
<span class="token number">0.2</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0.4</span> <span class="token comment">// 0</span>
<span class="token number">0.4</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0.8</span> <span class="token comment">// 0</span>
</code></pre></div><p>将该数字乘以 2 ，取出整数部分作为二进制表示的第 1 位；然后再将小数部分乘以 2，将得到的整数部分作为二进制表示的第 2 位；以此类推，直到小数部分为 0。所以我们得到 <code>0.1 = 2^-4 * 1.1001(0011)</code> ，那么 <code>0.2</code> 的演算也基本如上所示，只需要去掉第一步乘法，所以得到 <code>0.2 = 2^-3 * 1.1001(0011)</code>。</p> <p>所以 <code>2^-4 * 1.10011...001</code> 进位后就变成了 <code>2^-4 * 1.10011(0011 * 12次)010</code> 。那么把这两个二进制加起来会得出 <code>2^-2 * 1.0011(0011 * 11次)0100</code> , 这个值算成十进制就是 <code>0.30000000000000004</code></p> <p>下面说一下原生解决办法，如下代码所示</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">parseFloat</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="正则表达式"><a href="#正则表达式" aria-hidden="true" class="header-anchor">#</a> 正则表达式</h2> <h3 id="元字符"><a href="#元字符" aria-hidden="true" class="header-anchor">#</a> 元字符</h3> <table><thead><tr><th style="text-align:center;">元字符</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">.</td> <td style="text-align:center;">匹配任意字符除了换行符和回车符</td></tr> <tr><td style="text-align:center;">[]</td> <td style="text-align:center;">匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字</td></tr> <tr><td style="text-align:center;">^</td> <td style="text-align:center;">^9，这样使用代表匹配以 9 开头。[^9]，这样使用代表匹配方括号内除了 9 的字符</td></tr> <tr><td style="text-align:center;">{1,2}</td> <td style="text-align:center;">匹配 1 到 2 位字符</td></tr> <tr><td style="text-align:center;">(abc)</td> <td style="text-align:center;">只匹配和 abc 相同字符串</td></tr> <tr><td style="text-align:center;">|</td> <td style="text-align:center;">匹配 | 前后任意字符</td></tr> <tr><td style="text-align:center;">\</td> <td style="text-align:center;">转义</td></tr> <tr><td style="text-align:center;">*</td> <td style="text-align:center;">只匹配出现 0 次及以上 * 前的字符</td></tr> <tr><td style="text-align:center;">+</td> <td style="text-align:center;">只匹配出现 1 次及以上 + 前的字符</td></tr> <tr><td style="text-align:center;">?</td> <td style="text-align:center;">?之前字符可选</td></tr></tbody></table> <h3 id="修饰语"><a href="#修饰语" aria-hidden="true" class="header-anchor">#</a> 修饰语</h3> <table><thead><tr><th style="text-align:center;">修饰语</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">i</td> <td style="text-align:center;">忽略大小写</td></tr> <tr><td style="text-align:center;">g</td> <td style="text-align:center;">全局搜索</td></tr> <tr><td style="text-align:center;">m</td> <td style="text-align:center;">多行</td></tr></tbody></table> <h3 id="字符简写"><a href="#字符简写" aria-hidden="true" class="header-anchor">#</a> 字符简写</h3> <table><thead><tr><th style="text-align:center;">字符</th> <th style="text-align:center;">作用</th></tr></thead> <tbody><tr><td style="text-align:center;">\w</td> <td style="text-align:center;">匹配字母数字或下划线</td></tr> <tr><td style="text-align:center;">\W</td> <td style="text-align:center;">和上面相反</td></tr> <tr><td style="text-align:center;">\s</td> <td style="text-align:center;">匹配任意的空白字符</td></tr> <tr><td style="text-align:center;">\S</td> <td style="text-align:center;">和上面相反</td></tr> <tr><td style="text-align:center;">\d</td> <td style="text-align:center;">匹配数字</td></tr> <tr><td style="text-align:center;">\D</td> <td style="text-align:center;">和上面相反</td></tr> <tr><td style="text-align:center;">\b</td> <td style="text-align:center;">匹配单词的开始或结束</td></tr> <tr><td style="text-align:center;">\B</td> <td style="text-align:center;">和上面相反</td></tr></tbody></table> <h2 id="v8-下的垃圾回收机制"><a href="#v8-下的垃圾回收机制" aria-hidden="true" class="header-anchor">#</a> V8 下的垃圾回收机制</h2> <p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p> <h3 id="准确式gc"><a href="#准确式gc" aria-hidden="true" class="header-anchor">#</a> 准确式GC</h3> <ol><li>正确的根，可以直接识别出是指针还是非指针，都需要语言处理程序加2.工，即为准确式GC(Exact GC)</li> <li>打标签，将不明确的根的所有非指针与指针区分开。32位系统的指针是4的倍数，低2位一定是0，因此可以让非指针左移一位，而后将最后一位置1，如果溢出则换一个大的数据类型。</li> <li>不把寄存器和栈等当作根，而由处理程序来创建根。</li> <li>优点在于不存在指针不明确，可以使用复制移动算法。</li> <li>缺点则是需要语言处理程序对GC做支持，而且打标签等方式需要消耗资源与性能。</li></ol> <h3 id="新生代算法"><a href="#新生代算法" aria-hidden="true" class="header-anchor">#</a> 新生代算法</h3> <p>新生代中的对象一般存活时间较短，采用空间换取事件的Scavenge GC 算法，尽可能快的回收内存。</p> <p>简单来说，将内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p> <h3 id="老生代算法"><a href="#老生代算法" aria-hidden="true" class="header-anchor">#</a> 老生代算法</h3> <p>老生代中的对象一般存活时间较长且数量较多，使用了额两个算法，分别是标记清除算法和标记压缩算法。</p> <p>在将算法之前，先来说下什么情况下对象会出现在老生代空间中：</p> <ul><li>新生代中的对象是否已经经历过一次Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li> <li>To 空间的的对象占比大小超过 25%。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li></ul> <p>老生代中的空间很复杂，有如下几个空间</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">enum</span> AllocationSpace <span class="token punctuation">{</span>
  <span class="token comment">// TODO(v8:7464): Actually map this space's memory as read-only.</span>
  <span class="token constant">RO_SPACE</span><span class="token punctuation">,</span>    <span class="token comment">// 不变的对象空间</span>
  <span class="token constant">NEW_SPACE</span><span class="token punctuation">,</span>   <span class="token comment">// 新生代用于 GC 复制算法的空间</span>
  <span class="token constant">OLD_SPACE</span><span class="token punctuation">,</span>   <span class="token comment">// 老生代常驻对象空间</span>
  <span class="token constant">CODE_SPACE</span><span class="token punctuation">,</span>  <span class="token comment">// 老生代代码对象空间</span>
  <span class="token constant">MAP_SPACE</span><span class="token punctuation">,</span>   <span class="token comment">// 老生代 map 对象</span>
  <span class="token constant">LO_SPACE</span><span class="token punctuation">,</span>    <span class="token comment">// 老生代大空间对象</span>
  <span class="token constant">NEW_LO_SPACE</span><span class="token punctuation">,</span>  <span class="token comment">// 新生代大空间对象</span>

  <span class="token constant">FIRST_SPACE</span> <span class="token operator">=</span> <span class="token constant">RO_SPACE</span><span class="token punctuation">,</span>
  <span class="token constant">LAST_SPACE</span> <span class="token operator">=</span> <span class="token constant">NEW_LO_SPACE</span><span class="token punctuation">,</span>
  <span class="token constant">FIRST_GROWABLE_PAGED_SPACE</span> <span class="token operator">=</span> <span class="token constant">OLD_SPACE</span><span class="token punctuation">,</span>
  <span class="token constant">LAST_GROWABLE_PAGED_SPACE</span> <span class="token operator">=</span> <span class="token constant">MAP_SPACE</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>在老生代中，以下情况会先启动标记清除算法：</p> <ul><li>某一个空间没有分块的时候</li> <li>空间中对象占比超过一定限制</li> <li>空间不能保证新生代中的对象移动到老生代中</li></ul> <p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html" target="_blank" rel="noopener noreferrer">该博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 详细阅读。</p> <p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">8/5/2019, 5:52:08 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/frontend/" class="prev router-link-active">
          Home
        </a></span> <span class="next"><a href="/frontend/browser/">
          浏览器
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/frontend/assets/js/app.564d1f95.js" defer></script><script src="/frontend/assets/js/2.3b24a225.js" defer></script><script src="/frontend/assets/js/7.55063cd5.js" defer></script>
  </body>
</html>
